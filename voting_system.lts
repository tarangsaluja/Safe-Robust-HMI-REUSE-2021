//Constants and ranges


//constant for whether or not official is in booth
const No_eo = 0
const Yes_eo = 1

range Eo_state = No_eo .. Yes_eo

//constant for whether or not voter is in booth
const No_v = 2
const Yes_v = 3

range V_state = No_v .. Yes_v


//Booth process 
BOOTH = (v.enter -> password -> BOOTH[No_eo][Yes_v]),
BOOTH[e:Eo_state][v:V_state] = 
(
		when (e == No_eo && v == No_v)
			eo.in -> BOOTH[Yes_eo][No_v]
		|
		when (e == No_eo && v == No_v)
			v.in -> BOOTH[No_eo][Yes_v]
		|
		when (e == No_eo && v == Yes_v)
			v.out -> BOOTH[No_eo][No_v]
		|
		when (e == Yes_eo && v == No_v)
			eo.out -> BOOTH[No_eo][No_v]
		|
		when (e == No_eo && v == Yes_v)
			confirm -> v.exit -> BOOTH
		|
		when (e == Yes_eo && v == No_v)
			confirm -> eo.exit -> BOOTH
		|
		check[e][v] -> BOOTH[e][v]
). 

//Voting system process, synchronized with v.enter and password, checks to make sure someone is in booth at every step
VOTE = (v.enter -> password -> AUTH), 
AUTH = (check[e:Eo_state][v:V_state] -> if !(e == No_eo && v == No_v) then (select -> VOTE_STATE)
																	  else AUTH),
VOTE_STATE = (check[e:Eo_state][v:V_state] -> if !(e == No_eo && v == No_v) then (unselect -> AUTH | vote -> VOTED)
																	  else VOTE_STATE),
VOTED = (check[e:Eo_state][v:V_state] -> if !(e == No_eo && v == No_v) then (unvote-> VOTE_STATE | confirm -> exit -> VOTE)
																	  else VOTE). 
 

||VOTE_SYS = (BOOTH || VOTE)/{exit/v.exit, exit/eo.exit}. //synchronize so that exit happens at once
